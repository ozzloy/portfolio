* minimal complete example of hello world clojure app
show a minimal complete example of a hello world clojure app that uses
deps.edn

Here's a minimal Clojure hello world app with deps.edn:

#+begin_src clojure
  ; deps.edn
  {:paths ["src"]
   :deps {org.clojure/clojure {:mvn/version "1.11.1"}}}

  ; src/hello/core.clj
  (ns hello.core)

  (defn -main []
    (println "Hello, World!"))
#+end_src

Run it with:
#+begin_src bash
  clj -M -m hello.core
#+end_src

* common uses of deps.edn
what are some common things to do with deps.edn?

Common uses for deps.edn include:

1. Declaring project dependencies
#+begin_src clojure
  {:deps {org.clojure/clojure {:mvn/version "1.11.1"}
          compojure/compojure {:mvn/version "1.6.3"}}}
#+end_src

2. Setting up aliases for different profiles
#+begin_src clojure
  {:aliases
   {:dev {:extra-deps {...}}
    :test {:extra-paths ["test"]}
    :build {:deps {...}}}}
#+end_src

3. Adding extra source paths
#+begin_src clojure
  {:paths ["src" "resources"]}
#+end_src

4. Defining JVM options
#+begin_src clojure
{:jvm-opts ["-Xms512m" "-Xmx1024m"]}
#+end_src

* figwheel-main minimal complete

show a minimal complete figwheel main example.

Here's a minimal Figwheel-main example:

#+begin_src clojure
  ; deps.edn
  {:deps {org.clojure/clojure {:mvn/version "1.11.1"}
          org.clojure/clojurescript {:mvn/version "1.11.60"}
          com.bhauman/figwheel-main {:mvn/version "0.2.18"}}
   :paths ["src" "resources" "target"]
   :aliases {:fig {:main-opts ["-m" "figwheel.main" "-b" "dev" "-r"]}}}

  ; dev.cljs.edn
  ^{:watch-dirs ["src"]
    :css-dirs ["resources/public/css"]}
  {:main hello.core}

  ; src/hello/core.cljs
  (ns hello.core)

  (defn init []
    (js/console.log "Hello, Figwheel!"))

  (init)

  ; resources/public/index.html
  <!DOCTYPE html>
  <html>
    <head></head>
    <body>
      <div id="app"></div>
      <script src="cljs-out/dev-main.js"></script>
    </body>
  </html>
#+end_src

Run with:
#+begin_src bash
  clj -M:fig
#+end_src

Visit: http://localhost:9500

* align forms dir local

** first try
what are some options i can put in my .dir-locals for clojure and
clojurescript?  include things for aligning forms.  i'm also interested
in cider options and test running options.

Here's a sample .dir-locals.el for Clojure/ClojureScript projects:

#+begin_src elisp
((clojure-mode . ((clojure-align-forms-automatically . t)
                  (clojure-indent-style . :align-arguments)
                  (cider-clojure-cli-aliases . "dev:test")
                  (cider-preferred-build-tool . clojure-cli)
                  (cider-test-runner . "kaocha")
                  (eval . (put-clojure-indent 'match 1))
                  (eval . (put-clojure-indent 'reg-event-fx 0))))

 (clojurescript-mode . ((cider-default-cljs-repl . shadow)
                       (cider-shadow-default-options . "app"))))
#+end_src

These are common options, but you can customize based on your needs.
The alignment and indentation options are particularly useful for
consistent formatting.
** second try, add figwheel main

what are some options i can put in my .dir-locals for clojure and
clojurescript?  include things for aligning forms.  i'm also interested
in cider options, test running options, and figwheel main options.

Here's a sample .dir-locals.el for Clojure/ClojureScript projects:

#+begin_src elisp
  ((clojure-mode . ((clojure-align-forms-automatically . t)
                    (clojure-indent-style . :always-align)
                    (fill-column . 80)))

   (clojurescript-mode . ((clojure-align-forms-automatically . t)
                         (cider-default-cljs-repl . figwheel-main)
                         (cider-figwheel-main-default-options . ":dev")))

   (cider-repl-mode . ((cider-preferred-build-tool . clojure-cli)
                      (cider-test-show-report-on-success . t)
                      (cider-repl-display-help-banner . nil)
                      (cider-repl-history-size . 1000)))

   (clojure-test-mode . ((cider-test-show-report-on-success . t)
                        (cider-auto-test-mode . t))))
#+end_src

These are common options, but there are many more available depending
on your needs.

* drilling down on deps.edn configuration

here's the files in my bare minimum clojurescript project.
#+begin_src clojure
  ; deps.edn
  {:paths ["src" "resources" "target"]
  :deps {org.clojure/clojure       {:mvn/version "1.12.0"}
         org.clojure/clojurescript {:mvn/version "1.11.132"}
         com.bhauman/figwheel-main {:mvn/version "0.2.20"}}
  :aliases {:fig {:main-opts ["-m" "figwheel.main" "-b" "dev" "-r"]}}}

  ; dev.cljs.edn
  ^{:watch-dirs ["src"]
    :css-dirs ["resources/public/css"]}
  {:main to.tuo.portfolio}

  ; src/to/tuo/portfolio.cljs
  (ns to.tuo.portfolio)

  (defn init []
    (js/console.log "hello, figwheel"))

  (init)
#+end_src

#+begin_src elisp
  ; .dir-locals.el
  ((clojure-mode . ((clojure-align-forms-automatically . t)
                    (clojure-indent-style . :always-align)
                    (fill-column . 70)))

   (clojurescript-mode . ((clojure-align-forms-automatically . t)
                          (fill-column . 70)
                          (cider-default-cljs-repl . figwheel-main)
                          (cider-figwheel-main-default-options . ":dev")))

   (cider-repl-mode . ((cider-preferred-build-tool . clojure-cli)
                       (cider-test-show-report-on-success . t)
                       (cider-repl-display-help-banner . nil)
                       (cider-repl-history-size . 1000)))

   (clojure-test-mode . ((cider-test-show-report-on-success . t)
                         (cider-auto-test-mode . t))))
#+end_src

#+begin_src html
  ; resources/public/index.html
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8" />
      <style>
        body {
          color: white;
          background-color: black;
        }
      </style>
      <title>figwheel main example</title>
    </head>
    <body>
      <script src="/cljs-out/dev-main.js"></script>
    </body>
  </html>
#+end_src

please explain the command line options for the alias fig. could i
change it if i'm going to use cider in spacemacs to run figwheel and
connect a repl to the code in the file =src/to/tuo/portfolio.cljs= and
to a browser window for evaluation? how do i change =deps.edn= for
that? how do i then launch a cider session and connect it to the code
and the browser?  what do the options in =.dir-locals.el= do?  are there
more options i could add to automate starting the cider repl?


Let's break this down:

1. The =:fig= alias options:
   - =-m figwheel.main=: runs figwheel.main as the entry point
   - =-b dev=: uses the =dev.cljs.edn= build configuration
   - =-r=: auto-runs the build on startup

2. For CIDER/Spacemacs usage, you can remove the =:fig= alias as CIDER
   will handle the REPL startup. The deps.edn can remain as is, just
   with the dependencies.

3. To start a CIDER session in Spacemacs:
   - =SPC m s i= (cider-jack-in-cljs)
   - Select =figwheel-main= when prompted
   - Enter =:dev= when asked for options
   - Browser will open automatically

4. .dir-locals.el breakdown:
   - =cider-default-cljs-repl=: sets figwheel-main as default CLJS REPL
   - =cider-figwheel-main-default-options=: pre-sets =:dev= build option
   - Other options control formatting and REPL behavior

5. Additional .dir-locals.el options you could add:
#+begin_src elisp
((clojurescript-mode
  . ((cider-preferred-build-tool . clojure-cli)
     (cider-default-cljs-repl . figwheel-main)
     (cider-figwheel-main-default-options . ":dev")
     (cider-repl-init-code . ("(require 'to.tuo.portfolio)")))))
#+end_src

This will automate more of the startup sequence.

* clojurescript to add html
i have the following minimal clojurescript project

#+begin_src clojure :file deps.edn
  {:paths ["src" "resources" "target"]
   :deps {org.clojure/clojure       {:mvn/version "1.12.0"}
          org.clojure/clojurescript {:mvn/version "1.11.132"}
          com.bhauman/figwheel-main {:mvn/version "0.2.20"}}}
#+end_src

#+begin_src clojure :file dev.cljs.edn
  ^{:watch-dirs ["src"]
    :css-dirs ["resources/public/css"]}
  {:main to.tuo.portfolio}
#+end_src

#+begin_src html :file resources/public/index.html
  <!doctype html>
  <html>
    <head>
      <meta charset="UTF-8" />
      <style>
        body {
          color: white;
          background-color: black;
        }
      </style>
      <title>figwheel main example</title>
    </head>
    <body>
      <script src="/cljs-out/dev-main.js"></script>
    </body>
  </html>
#+end_src

#+begin_src clojure :file src/to/tuo/portfolio.cljs
  (ns to.tuo.portfolio)

  (defn init []
    (js/console.log "hello, figwheel"))

  (init)
#+end_src

how do i add content to the page using clojure code?


To add content to the page in ClojureScript, you'll need to use
JavaScript's DOM manipulation methods. Here's a simple example:

#+begin_src clojure
(ns to.tuo.portfolio)

(defn init []
  (let [app (.. js/document (createElement "div"))
        text (.. js/document (createTextNode "Hello from ClojureScript!"))]
    (.. app (appendChild text))
    (.. js/document.body (appendChild app))))

(init)
#+end_src

For more convenient DOM manipulation, consider using libraries like:
- =reagent= (React wrapper)
- =hiccup= (HTML generation)
- =dommy= (DOM manipulation)

The most popular approach is using Reagent. Here's how to add it:

1. Add to deps.edn:
#+begin_src clojure
{:deps {reagent/reagent {:mvn/version "1.2.0"}}}
#+end_src

2. Use it in your code:
#+begin_src clojure
(ns to.tuo.portfolio
  (:require [reagent.dom :as rdom]
            [reagent.core :as r]))

(defn app []
  [:div "Hello from Reagent!"])

(defn init []
  (rdom/render [app]
               (.. js/document (getElementById "app"))))

(init)
#+end_src

Remember to add a div with id="app" to your HTML file if using Reagent.

** hiccup minimal complete

show a minimal complete example of creating html with hiccup, starting
with the following project

#+begin_src clojure :file deps.edn
  {:paths ["src" "resources" "target"]
   :deps {org.clojure/clojure       {:mvn/version "1.12.0"}
          org.clojure/clojurescript {:mvn/version "1.11.132"}
          com.bhauman/figwheel-main {:mvn/version "0.2.20"}}}
#+end_src

#+begin_src clojure :file dev.cljs.edn
  ^{:watch-dirs ["src"]
    :css-dirs ["resources/public/css"]
    :open-url false}
  {:main to.tuo.portfolio}
#+end_src

#+begin_src html :file resources/public/index.html
  <!doctype html>
  <html>
    <head>
      <meta charset="UTF-8" />
      <style>
        body {
          color: white;
          background-color: black;
        }
      </style>
      <title>figwheel main example</title>
    </head>
    <body>
      <script src="/cljs-out/dev-main.js"></script>
    </body>
  </html>
#+end_src

#+begin_src clojure :file src/to/tuo/portfolio.cljs
  (ns to.tuo.portfolio)

  (defn init []
    (js/console.log "hello, figwheel"))

  (init)
#+end_src


Here's a minimal example using Hiccup. First, add Hiccup to your
deps.edn:

#+begin_src clojure
;; deps.edn
{:paths ["src" "resources" "target"]
 :deps {org.clojure/clojure       {:mvn/version "1.12.0"}
        org.clojure/clojurescript {:mvn/version "1.11.132"}
        com.bhauman/figwheel-main {:mvn/version "0.2.20"}
        hiccup/hiccup             {:mvn/version "1.0.5"}}}
#+end_src

Then modify your portfolio.cljs:

#+begin_src clojure
(ns to.tuo.portfolio
  (:require [hiccup.core :refer [html]]))

(def my-element
  [:div
   [:h1 "Hello Hiccup"]
   [:p "This is a paragraph"]])

(defn init []
  (set! (.-innerHTML (.-body js/document))
        (html my-element)))

(init)
#+end_src

This will render a div containing an h1 and p element when the page
loads. The html function converts the Hiccup data structure into HTML
string format.

*** troubleshooting hiccup2

in this clojurescript code, when the namespace declaration changes
from
#+begin_src clojurescript :file src/to/tuo/portfolio.cljs
  (ns to.tuo.portfolio)
#+end_src

to

#+begin_src clojurescript :file src/to/tuo/portfolio.cljs
  (ns to.tuo.portfolio
    (:require [hiccup2.core :as h]))
#+end_src

the code stops loading in the browser.  why?


This likely occurs because the =hiccup2.core= namespace is meant for
server-side Clojure, not ClojureScript. Hiccup2 is not compatible with
ClojureScript. For client-side HTML generation in ClojureScript, you
should consider using alternatives like:

1. =hiccups= library
2. =reagent=
3. =rum=

** reagent minimal complete

show a minimal complete example of creating html with reagent, starting
with the following project

#+begin_src clojure :file deps.edn
  {:paths ["src" "resources" "target"]
   :deps {org.clojure/clojure       {:mvn/version "1.12.0"}
          org.clojure/clojurescript {:mvn/version "1.11.132"}
          com.bhauman/figwheel-main {:mvn/version "0.2.20"}}}
#+end_src

#+begin_src clojure :file dev.cljs.edn
  ^{:watch-dirs ["src"]
    :css-dirs ["resources/public/css"]
    :open-url false}
  {:main to.tuo.portfolio}
#+end_src

#+begin_src html :file resources/public/index.html
  <!doctype html>
  <html>
    <head>
      <meta charset="UTF-8" />
      <style>
        body {
          color: white;
          background-color: black;
        }
      </style>
      <title>figwheel main example</title>
    </head>
    <body>
      <script src="/cljs-out/dev-main.js"></script>
    </body>
  </html>
#+end_src

#+begin_src clojure :file src/to/tuo/portfolio.cljs
  (ns to.tuo.portfolio)

  (defn init []
    (js/console.log "hello, figwheel"))

  (init)
#+end_src


Here's a minimal Reagent example. First, add Reagent to your deps.edn:

#+begin_src clojure
;; deps.edn
{:deps {reagent/reagent {:mvn/version "1.2.0"}
        ;; ... other deps ...}}
#+end_src

Update your index.html to include a div for mounting:
#+begin_src html
<body>
  <div id="app"></div>
  <script src="/cljs-out/dev-main.js"></script>
</body>
#+end_src

Then modify your portfolio.cljs:
#+begin_src clojure
(ns to.tuo.portfolio
  (:require [reagent.dom :as rdom]
            [reagent.core :as r]))

(defn hello []
  [:div
   [:h1 "Hello from Reagent"]
   [:p "This is a component"]])

(defn ^:export init []
  (rdom/render [hello]
               (js/document.getElementById "app")))

(init)
#+end_src

Run with =clj -M:fig:build= and you should see the heading rendered in
white on black.

after doing that, the following error appears in the browser
#+begin_quote
Could not Find Namespace target/public/cljs-out/dev/reagent/impl/component.cljs
clojure.lang.ExceptionInfo: No such namespace: react, could not locate react.cljs, react.cljc, or JavaScript source providing "react" in file target/public/cljs-out/dev/reagent/impl/component.cljs

1  (ns reagent.impl.component
2    (:require [goog.object :as gobj]
3              [react :as react]
                ^---
                     No such namespace: react, could not locate react.cljs, react.cljc, or JavaScript source providing "react" in file 
                                                                                target/public/cljs-out/dev/reagent/impl/component.cljs 
4              [reagent.impl.util :as util]
5              [reagent.impl.batching :as batch]
6              [reagent.impl.protocols :as p]
7              [reagent.ratom :as ratom]
8              [reagent.debug :refer-macros [dev? warn warn-unless assert-callable]]))

Please see line 3 of file target/public/cljs-out/dev/reagent/impl/component.cljs
#+end_quote

Add the =react= and =react-dom= dependencies to your =deps.edn=:

#+begin_src clojure
{:paths ["src" "resources" "target"]
 :deps {org.clojure/clojure       {:mvn/version "1.12.0"}
       org.clojure/clojurescript {:mvn/version "1.11.132"}
       com.bhauman/figwheel-main {:mvn/version "0.2.20"}
       reagent/reagent           {:mvn/version "1.2.0"}
       cljsjs/react             {:mvn/version "17.0.2-0"}
       cljsjs/react-dom         {:mvn/version "17.0.2-0"}}}
#+end_src

This should resolve the missing React dependency error. Clean your target directory and restart figwheel.
* update repl after modifying deps.edn

how do i get the new library into the running cider repl after
updating deps.edn?


In CIDER, you can reload dependencies by using =cider-refresh= (bound
to =C-c C-x=) or by evaluating =(require
'[clojure.tools.deps.alpha.repl :refer [refresh]])= followed by
=(refresh)= in the REPL.

Alternatively, you can restart the REPL completely with
=cider-restart= (bound to =C-c C-q C-r=).

* auto align clojure code
the reagent line in this does not align with the prior lines:
#+begin_src clojure :file deps.edn
  {:paths ["src" "resources" "target"]
   :deps  {org.clojure/clojure       {:mvn/version "1.12.0"}
           org.clojure/clojurescript {:mvn/version "1.11.132"}
           com.bhauman/figwheel-main {:mvn/version "0.2.20"}
           reagent/reagent {:mvn/version "1.2.0"}}}
#+end_src

#+begin_src elisp :file .dir-locals.el
  ((clojure-mode
    . ((clojure-align-forms-automatically . t)
       (clojure-indent-style . :always-align))))
#+end_src

the map in =deps.edn= does not align when i hit TAB. the map does
align like this after manually invoking clojure-align:

#+begin_src clojure :file deps.edn
  {:paths ["src" "resources" "target"]
   :deps  {org.clojure/clojure       {:mvn/version "1.12.0"}
           org.clojure/clojurescript {:mvn/version "1.11.132"}
           com.bhauman/figwheel-main {:mvn/version "0.2.20"}
           reagent/reagent           {:mvn/version "1.2.0"}}}
#+end_src

why?  how do i get it to align automatically in spacemacs?

To get automatic alignment in Spacemacs with Clojure code, you need to:

1. Enable =clojure-mode= alignment in your =user-config=:
#+begin_src elisp
(use-package clojure-mode
  :config
  (setq clojure-indent-style 'align-arguments)
  (setq clojure-align-forms-automatically t))
#+end_src

Add this to your =dotspacemacs/user-config= in =.spacemacs=.

If that doesn't work, you can also try binding the align command to save:
#+begin_src elisp
(add-hook 'clojure-mode-hook
          (lambda ()
            (add-hook 'before-save-hook 'clojure-align nil 'local)))
#+end_src

The =.dir-locals.el= approach should work too, but sometimes Spacemacs
configuration takes precedence. Try the =user-config= approach first.

** make emacs align clojure forms on file save
make spacemacs align clojure forms on file save.

Add this to your init.el:

#+begin_src elisp
(add-hook 'before-save-hook
          (lambda ()
            (when (eq major-mode 'clojure-mode)
              (indent-region (point-min) (point-max)))))
#+end_src

This will auto-indent Clojure code when saving files in clojure-mode.

that did not work.  in fact, when the file looks like this
#+begin_src clojure
  {:paths ["src" "resources" "target"]
   :deps  {org.clojure/clojure       {:mvn/version "1.12.0"}
           org.clojure/clojurescript {:mvn/version "1.11.132"}
           com.bhauman/figwheel-main {:mvn/version "0.2.20"}
           reagent/reagent  {:mvn/version "1.2.0"}}}
#+end_src

the reagent line is not aligned with the rest of the map lines, even
after i highlight everything and manually invoke =indent-region=.

there's even configuration in dir-locals:
#+begin_src elisp :file .dir-locals.el
  ((clojure-mode
    . ((clojure-align-forms-automatically . t)
       (clojure-indent-style . :always-align))))
#+end_src


For Clojure map alignment, you might want to try =clojure-align=
instead. Add this to your init.el:

#+begin_src elisp
  (add-hook 'before-save-hook
            (lambda ()
              (when (eq major-mode 'clojure-mode)
                (clojure-align (point-min) (point-max)))))
#+end_src

Also, check that your .dir-locals.el file is properly closed with a
closing parenthesis:

#+begin_src elisp
  ((clojure-mode
    . ((clojure-align-forms-automatically . t)
       (clojure-indent-style . :always-align))))
#+end_src

If issues persist, you can manually align using =M-x clojure-align= on
the region.

* ReactDOM.render no longer supported
this clojurescript reagent code
#+begin_src clojure :file src/to/tuo/portfolio.cljs
  (ns to.tuo.portfolio
    (:require [reagent.dom :as rdom]))

  (defn hello []
    [:div
     [:h1 "hello from reagent"]
     [:p "this is a paragraph"]])

  (defn ^:export init []
    (js/console.log "hello, figwheel!")
    (rdom/render [hello] (js/document.getElementById "app")))

  (init)
#+end_src

gets the following error in the browser console
#+begin_quote
Warning: ReactDOM.render is no longer supported in React 18. Use
createRoot instead. Until you switch to the new API, your app will
behave as if it's running React 17. Learn more:
https://reactjs.org/link/switch-to-createroot <anonymous
code>:1:145535
#+end_quote

which shows this code snippet
#+begin_src js
  // Before
  import { render } from 'react-dom';
  const container = document.getElementById('app');
  render(<App tab="home" />, container);

  // After
  import { createRoot } from 'react-dom/client';
  const container = document.getElementById('app');
  const root = createRoot(container); // createRoot(container!) if you use TypeScript
  root.render(<App tab="home" />);
#+end_src

update the clojure code in the same way the javascript was updated.


Here's the updated ClojureScript code using =createRoot=:

#+begin_src clojure
  (ns to.tuo.portfolio
    (:require [reagent.dom.client :as rdom-client]))

  (defn hello []
    [:div
     [:h1 "hello from reagent"]
     [:p "this is a paragraph"]])

  (defn ^:export init []
    (js/console.log "hello, figwheel!")
    (let [root (rdom-client/create-root
                (js/document.getElementById "app"))]
      (.render root [hello])))

  (init)
#+end_src

The main changes are:
1. Require =reagent.dom.client= instead of =reagent.dom=
2. Use =create-root= to create a root instance
3. Call =.render= on the root instance


that code does not render anything in the browser and now i see this
#+begin_quote
Warning: Functions are not valid as a React child. This may happen if
you return a Component instead of <Component /> from render. Or maybe
you meant to call this function rather than return it. <anonymous
code>:1:145535
#+end_quote
