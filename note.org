* portfolio site checklist
** TODO include a professional photo
** DONE include "About Me" Paragraph or professional bio
CLOSED: [2025-02-03 Mon]
** DONE include section for future projects
CLOSED: [2025-02-04 Tue]
** DONE include list all known technologies / skills
CLOSED: [2025-02-06 Thu]
** DONE add github and linkedin links
CLOSED: [2025-02-04 Tue]
** TODO include section for hobbies, writings, cool stuff about you!
** TODO add contact information
** TODO project links
*** TODO include live links, code links
** TODO include pdf resume link
** TODO include project walk-through videos (bonus)
** TODO include testimonials (bonus)

* minimal complete example of hello world clojure app
show a minimal complete example of a hello world clojure app that uses
deps.edn

Here's a minimal Clojure hello world app with deps.edn:

#+begin_src clojure :file deps.edn
  {:paths ["src"]
   :deps {org.clojure/clojure {:mvn/version "1.11.1"}}}
#+end_src

#+begin_src clojure :file src/hello/core.clj
  (ns hello.core)

  (defn -main []
    (println "Hello, World!"))
#+end_src

Run it with:
#+begin_src bash
  clj -M -m hello.core
#+end_src

* common uses of deps.edn
what are some common things to do with deps.edn?

Common uses for deps.edn include:

1. Declaring project dependencies
#+begin_src clojure
  {:deps {org.clojure/clojure {:mvn/version "1.11.1"}
          compojure/compojure {:mvn/version "1.6.3"}}}
#+end_src

2. Setting up aliases for different profiles
#+begin_src clojure
  {:aliases
   {:dev {:extra-deps {...}}
    :test {:extra-paths ["test"]}
    :build {:deps {...}}}}
#+end_src

3. Adding extra source paths
#+begin_src clojure
  {:paths ["src" "resources"]}
#+end_src

4. Defining JVM options
#+begin_src clojure
{:jvm-opts ["-Xms512m" "-Xmx1024m"]}
#+end_src

* figwheel-main minimal complete

show a minimal complete figwheel main example.

Here's a minimal Figwheel-main example:

#+begin_src clojure
  ; deps.edn
  {:deps {org.clojure/clojure {:mvn/version "1.11.1"}
          org.clojure/clojurescript {:mvn/version "1.11.60"}
          com.bhauman/figwheel-main {:mvn/version "0.2.18"}}
   :paths ["src" "resources" "target"]
   :aliases {:fig {:main-opts ["-m" "figwheel.main" "-b" "dev" "-r"]}}}

  ; dev.cljs.edn
  ^{:watch-dirs ["src"]
    :css-dirs ["resources/public/css"]}
  {:main hello.core}

  ; src/hello/core.cljs
  (ns hello.core)

  (defn init []
    (js/console.log "Hello, Figwheel!"))

  (init)

  ; resources/public/index.html
  <!DOCTYPE html>
  <html>
    <head></head>
    <body>
      <div id="app"></div>
      <script src="cljs-out/dev-main.js"></script>
    </body>
  </html>
#+end_src

Run with:
#+begin_src bash
  clj -M:fig
#+end_src

Visit: http://localhost:9500

* align forms dir local

** first try
what are some options i can put in my .dir-locals for clojure and
clojurescript?  include things for aligning forms.  i'm also interested
in cider options and test running options.

Here's a sample .dir-locals.el for Clojure/ClojureScript projects:

#+begin_src elisp
((clojure-mode . ((clojure-align-forms-automatically . t)
                  (clojure-indent-style . :align-arguments)
                  (cider-clojure-cli-aliases . "dev:test")
                  (cider-preferred-build-tool . clojure-cli)
                  (cider-test-runner . "kaocha")
                  (eval . (put-clojure-indent 'match 1))
                  (eval . (put-clojure-indent 'reg-event-fx 0))))

 (clojurescript-mode . ((cider-default-cljs-repl . shadow)
                       (cider-shadow-default-options . "app"))))
#+end_src

These are common options, but you can customize based on your needs.
The alignment and indentation options are particularly useful for
consistent formatting.
** second try, add figwheel main

what are some options i can put in my .dir-locals for clojure and
clojurescript?  include things for aligning forms.  i'm also interested
in cider options, test running options, and figwheel main options.

Here's a sample .dir-locals.el for Clojure/ClojureScript projects:

#+begin_src elisp
  ((clojure-mode . ((clojure-align-forms-automatically . t)
                    (clojure-indent-style . :always-align)
                    (fill-column . 80)))

   (clojurescript-mode . ((clojure-align-forms-automatically . t)
                         (cider-default-cljs-repl . figwheel-main)
                         (cider-figwheel-main-default-options . ":dev")))

   (cider-repl-mode . ((cider-preferred-build-tool . clojure-cli)
                      (cider-test-show-report-on-success . t)
                      (cider-repl-display-help-banner . nil)
                      (cider-repl-history-size . 1000)))

   (clojure-test-mode . ((cider-test-show-report-on-success . t)
                        (cider-auto-test-mode . t))))
#+end_src

These are common options, but there are many more available depending
on your needs.

* drilling down on deps.edn configuration

here's the files in my bare minimum clojurescript project.
#+begin_src clojure
  ; deps.edn
  {:paths ["src" "resources" "target"]
  :deps {org.clojure/clojure       {:mvn/version "1.12.0"}
         org.clojure/clojurescript {:mvn/version "1.11.132"}
         com.bhauman/figwheel-main {:mvn/version "0.2.20"}}
  :aliases {:fig {:main-opts ["-m" "figwheel.main" "-b" "dev" "-r"]}}}

  ; dev.cljs.edn
  ^{:watch-dirs ["src"]
    :css-dirs ["resources/public/css"]}
  {:main to.tuo.portfolio}

  ; src/to/tuo/portfolio.cljs
  (ns to.tuo.portfolio)

  (defn init []
    (js/console.log "hello, figwheel"))

  (init)
#+end_src

#+begin_src elisp
  ; .dir-locals.el
  ((clojure-mode . ((clojure-align-forms-automatically . t)
                    (clojure-indent-style . :always-align)
                    (fill-column . 70)))

   (clojurescript-mode . ((clojure-align-forms-automatically . t)
                          (fill-column . 70)
                          (cider-default-cljs-repl . figwheel-main)
                          (cider-figwheel-main-default-options . ":dev")))

   (cider-repl-mode . ((cider-preferred-build-tool . clojure-cli)
                       (cider-test-show-report-on-success . t)
                       (cider-repl-display-help-banner . nil)
                       (cider-repl-history-size . 1000)))

   (clojure-test-mode . ((cider-test-show-report-on-success . t)
                         (cider-auto-test-mode . t))))
#+end_src

#+begin_src html
  ; resources/public/index.html
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8" />
      <style>
        body {
          color: white;
          background-color: black;
        }
      </style>
      <title>figwheel main example</title>
    </head>
    <body>
      <script src="/cljs-out/dev-main.js"></script>
    </body>
  </html>
#+end_src

please explain the command line options for the alias fig. could i
change it if i'm going to use cider in spacemacs to run figwheel and
connect a repl to the code in the file =src/to/tuo/portfolio.cljs= and
to a browser window for evaluation? how do i change =deps.edn= for
that? how do i then launch a cider session and connect it to the code
and the browser?  what do the options in =.dir-locals.el= do?  are there
more options i could add to automate starting the cider repl?


Let's break this down:

1. The =:fig= alias options:
   - =-m figwheel.main=: runs figwheel.main as the entry point
   - =-b dev=: uses the =dev.cljs.edn= build configuration
   - =-r=: auto-runs the build on startup

2. For CIDER/Spacemacs usage, you can remove the =:fig= alias as CIDER
   will handle the REPL startup. The deps.edn can remain as is, just
   with the dependencies.

3. To start a CIDER session in Spacemacs:
   - =SPC m s i= (cider-jack-in-cljs)
   - Select =figwheel-main= when prompted
   - Enter =:dev= when asked for options
   - Browser will open automatically

4. .dir-locals.el breakdown:
   - =cider-default-cljs-repl=: sets figwheel-main as default CLJS REPL
   - =cider-figwheel-main-default-options=: pre-sets =:dev= build option
   - Other options control formatting and REPL behavior

5. Additional .dir-locals.el options you could add:
#+begin_src elisp
((clojurescript-mode
  . ((cider-preferred-build-tool . clojure-cli)
     (cider-default-cljs-repl . figwheel-main)
     (cider-figwheel-main-default-options . ":dev")
     (cider-repl-init-code . ("(require 'to.tuo.portfolio)")))))
#+end_src

This will automate more of the startup sequence.

* clojurescript to add html
i have the following minimal clojurescript project

#+begin_src clojure :file deps.edn
  {:paths ["src" "resources" "target"]
   :deps {org.clojure/clojure       {:mvn/version "1.12.0"}
          org.clojure/clojurescript {:mvn/version "1.11.132"}
          com.bhauman/figwheel-main {:mvn/version "0.2.20"}}}
#+end_src

#+begin_src clojure :file dev.cljs.edn
  ^{:watch-dirs ["src"]
    :css-dirs ["resources/public/css"]}
  {:main to.tuo.portfolio}
#+end_src

#+begin_src html :file resources/public/index.html
  <!doctype html>
  <html>
    <head>
      <meta charset="UTF-8" />
      <style>
        body {
          color: white;
          background-color: black;
        }
      </style>
      <title>figwheel main example</title>
    </head>
    <body>
      <script src="/cljs-out/dev-main.js"></script>
    </body>
  </html>
#+end_src

#+begin_src clojure :file src/to/tuo/portfolio.cljs
  (ns to.tuo.portfolio)

  (defn init []
    (js/console.log "hello, figwheel"))

  (init)
#+end_src

how do i add content to the page using clojure code?


To add content to the page in ClojureScript, you'll need to use
JavaScript's DOM manipulation methods. Here's a simple example:

#+begin_src clojure
(ns to.tuo.portfolio)

(defn init []
  (let [app (.. js/document (createElement "div"))
        text (.. js/document (createTextNode "Hello from ClojureScript!"))]
    (.. app (appendChild text))
    (.. js/document.body (appendChild app))))

(init)
#+end_src

For more convenient DOM manipulation, consider using libraries like:
- =reagent= (React wrapper)
- =hiccup= (HTML generation)
- =dommy= (DOM manipulation)

The most popular approach is using Reagent. Here's how to add it:

1. Add to deps.edn:
#+begin_src clojure
{:deps {reagent/reagent {:mvn/version "1.2.0"}}}
#+end_src

2. Use it in your code:
#+begin_src clojure
(ns to.tuo.portfolio
  (:require [reagent.dom :as rdom]
            [reagent.core :as r]))

(defn app []
  [:div "Hello from Reagent!"])

(defn init []
  (rdom/render [app]
               (.. js/document (getElementById "app"))))

(init)
#+end_src

Remember to add a div with id="app" to your HTML file if using Reagent.

** hiccup minimal complete

show a minimal complete example of creating html with hiccup, starting
with the following project

#+begin_src clojure :file deps.edn
  {:paths ["src" "resources" "target"]
   :deps {org.clojure/clojure       {:mvn/version "1.12.0"}
          org.clojure/clojurescript {:mvn/version "1.11.132"}
          com.bhauman/figwheel-main {:mvn/version "0.2.20"}}}
#+end_src

#+begin_src clojure :file dev.cljs.edn
  ^{:watch-dirs ["src"]
    :css-dirs ["resources/public/css"]
    :open-url false}
  {:main to.tuo.portfolio}
#+end_src

#+begin_src html :file resources/public/index.html
  <!doctype html>
  <html>
    <head>
      <meta charset="UTF-8" />
      <style>
        body {
          color: white;
          background-color: black;
        }
      </style>
      <title>figwheel main example</title>
    </head>
    <body>
      <script src="/cljs-out/dev-main.js"></script>
    </body>
  </html>
#+end_src

#+begin_src clojure :file src/to/tuo/portfolio.cljs
  (ns to.tuo.portfolio)

  (defn init []
    (js/console.log "hello, figwheel"))

  (init)
#+end_src


Here's a minimal example using Hiccup. First, add Hiccup to your
deps.edn:

#+begin_src clojure
;; deps.edn
{:paths ["src" "resources" "target"]
 :deps {org.clojure/clojure       {:mvn/version "1.12.0"}
        org.clojure/clojurescript {:mvn/version "1.11.132"}
        com.bhauman/figwheel-main {:mvn/version "0.2.20"}
        hiccup/hiccup             {:mvn/version "1.0.5"}}}
#+end_src

Then modify your portfolio.cljs:

#+begin_src clojure
(ns to.tuo.portfolio
  (:require [hiccup.core :refer [html]]))

(def my-element
  [:div
   [:h1 "Hello Hiccup"]
   [:p "This is a paragraph"]])

(defn init []
  (set! (.-innerHTML (.-body js/document))
        (html my-element)))

(init)
#+end_src

This will render a div containing an h1 and p element when the page
loads. The html function converts the Hiccup data structure into HTML
string format.

*** troubleshooting hiccup2

in this clojurescript code, when the namespace declaration changes
from
#+begin_src clojurescript :file src/to/tuo/portfolio.cljs
  (ns to.tuo.portfolio)
#+end_src

to

#+begin_src clojurescript :file src/to/tuo/portfolio.cljs
  (ns to.tuo.portfolio
    (:require [hiccup2.core :as h]))
#+end_src

the code stops loading in the browser.  why?


This likely occurs because the =hiccup2.core= namespace is meant for
server-side Clojure, not ClojureScript. Hiccup2 is not compatible with
ClojureScript. For client-side HTML generation in ClojureScript, you
should consider using alternatives like:

1. =hiccups= library
2. =reagent=
3. =rum=

** reagent minimal complete

show a minimal complete example of creating html with reagent, starting
with the following project

#+begin_src clojure :file deps.edn
  {:paths ["src" "resources" "target"]
   :deps {org.clojure/clojure       {:mvn/version "1.12.0"}
          org.clojure/clojurescript {:mvn/version "1.11.132"}
          com.bhauman/figwheel-main {:mvn/version "0.2.20"}}}
#+end_src

#+begin_src clojure :file dev.cljs.edn
  ^{:watch-dirs ["src"]
    :css-dirs ["resources/public/css"]
    :open-url false}
  {:main to.tuo.portfolio}
#+end_src

#+begin_src html :file resources/public/index.html
  <!doctype html>
  <html>
    <head>
      <meta charset="UTF-8" />
      <style>
        body {
          color: white;
          background-color: black;
        }
      </style>
      <title>figwheel main example</title>
    </head>
    <body>
      <script src="/cljs-out/dev-main.js"></script>
    </body>
  </html>
#+end_src

#+begin_src clojure :file src/to/tuo/portfolio.cljs
  (ns to.tuo.portfolio)

  (defn init []
    (js/console.log "hello, figwheel"))

  (init)
#+end_src


Here's a minimal Reagent example. First, add Reagent to your deps.edn:

#+begin_src clojure
;; deps.edn
{:deps {reagent/reagent {:mvn/version "1.2.0"}
        ;; ... other deps ...}}
#+end_src

Update your index.html to include a div for mounting:
#+begin_src html
<body>
  <div id="app"></div>
  <script src="/cljs-out/dev-main.js"></script>
</body>
#+end_src

Then modify your portfolio.cljs:
#+begin_src clojure
(ns to.tuo.portfolio
  (:require [reagent.dom :as rdom]
            [reagent.core :as r]))

(defn hello []
  [:div
   [:h1 "Hello from Reagent"]
   [:p "This is a component"]])

(defn ^:export init []
  (rdom/render [hello]
               (js/document.getElementById "app")))

(init)
#+end_src

Run with =clj -M:fig:build= and you should see the heading rendered in
white on black.

after doing that, the following error appears in the browser
#+begin_quote
Could not Find Namespace target/public/cljs-out/dev/reagent/impl/component.cljs
clojure.lang.ExceptionInfo: No such namespace: react, could not locate react.cljs, react.cljc, or JavaScript source providing "react" in file target/public/cljs-out/dev/reagent/impl/component.cljs

1  (ns reagent.impl.component
2    (:require [goog.object :as gobj]
3              [react :as react]
                ^---
                     No such namespace: react, could not locate react.cljs, react.cljc, or JavaScript source providing "react" in file 
                                                                                target/public/cljs-out/dev/reagent/impl/component.cljs 
4              [reagent.impl.util :as util]
5              [reagent.impl.batching :as batch]
6              [reagent.impl.protocols :as p]
7              [reagent.ratom :as ratom]
8              [reagent.debug :refer-macros [dev? warn warn-unless assert-callable]]))

Please see line 3 of file target/public/cljs-out/dev/reagent/impl/component.cljs
#+end_quote

Add the =react= and =react-dom= dependencies to your =deps.edn=:

#+begin_src clojure
{:paths ["src" "resources" "target"]
 :deps {org.clojure/clojure       {:mvn/version "1.12.0"}
       org.clojure/clojurescript {:mvn/version "1.11.132"}
       com.bhauman/figwheel-main {:mvn/version "0.2.20"}
       reagent/reagent           {:mvn/version "1.2.0"}
       cljsjs/react             {:mvn/version "17.0.2-0"}
       cljsjs/react-dom         {:mvn/version "17.0.2-0"}}}
#+end_src

This should resolve the missing React dependency error. Clean your target directory and restart figwheel.
* update repl after modifying deps.edn

how do i get the new library into the running cider repl after
updating deps.edn?


In CIDER, you can reload dependencies by using =cider-refresh= (bound
to =C-c C-x=) or by evaluating =(require
'[clojure.tools.deps.alpha.repl :refer [refresh]])= followed by
=(refresh)= in the REPL.

Alternatively, you can restart the REPL completely with
=cider-restart= (bound to =C-c C-q C-r=).

* auto align clojure code
the reagent line in this does not align with the prior lines:
#+begin_src clojure :file deps.edn
  {:paths ["src" "resources" "target"]
   :deps  {org.clojure/clojure       {:mvn/version "1.12.0"}
           org.clojure/clojurescript {:mvn/version "1.11.132"}
           com.bhauman/figwheel-main {:mvn/version "0.2.20"}
           reagent/reagent {:mvn/version "1.2.0"}}}
#+end_src

#+begin_src elisp :file .dir-locals.el
  ((clojure-mode
    . ((clojure-align-forms-automatically . t)
       (clojure-indent-style . :always-align))))
#+end_src

the map in =deps.edn= does not align when i hit TAB. the map does
align like this after manually invoking clojure-align:

#+begin_src clojure :file deps.edn
  {:paths ["src" "resources" "target"]
   :deps  {org.clojure/clojure       {:mvn/version "1.12.0"}
           org.clojure/clojurescript {:mvn/version "1.11.132"}
           com.bhauman/figwheel-main {:mvn/version "0.2.20"}
           reagent/reagent           {:mvn/version "1.2.0"}}}
#+end_src

why?  how do i get it to align automatically in spacemacs?

To get automatic alignment in Spacemacs with Clojure code, you need to:

1. Enable =clojure-mode= alignment in your =user-config=:
#+begin_src elisp
(use-package clojure-mode
  :config
  (setq clojure-indent-style 'align-arguments)
  (setq clojure-align-forms-automatically t))
#+end_src

Add this to your =dotspacemacs/user-config= in =.spacemacs=.

If that doesn't work, you can also try binding the align command to save:
#+begin_src elisp
(add-hook 'clojure-mode-hook
          (lambda ()
            (add-hook 'before-save-hook 'clojure-align nil 'local)))
#+end_src

The =.dir-locals.el= approach should work too, but sometimes Spacemacs
configuration takes precedence. Try the =user-config= approach first.

** make emacs align clojure forms on file save
make spacemacs align clojure forms on file save.

Add this to your init.el:

#+begin_src elisp
(add-hook 'before-save-hook
          (lambda ()
            (when (eq major-mode 'clojure-mode)
              (indent-region (point-min) (point-max)))))
#+end_src

This will auto-indent Clojure code when saving files in clojure-mode.

that did not work.  in fact, when the file looks like this
#+begin_src clojure
  {:paths ["src" "resources" "target"]
   :deps  {org.clojure/clojure       {:mvn/version "1.12.0"}
           org.clojure/clojurescript {:mvn/version "1.11.132"}
           com.bhauman/figwheel-main {:mvn/version "0.2.20"}
           reagent/reagent  {:mvn/version "1.2.0"}}}
#+end_src

the reagent line is not aligned with the rest of the map lines, even
after i highlight everything and manually invoke =indent-region=.

there's even configuration in dir-locals:
#+begin_src elisp :file .dir-locals.el
  ((clojure-mode
    . ((clojure-align-forms-automatically . t)
       (clojure-indent-style . :always-align))))
#+end_src


For Clojure map alignment, you might want to try =clojure-align=
instead. Add this to your init.el:

#+begin_src elisp
  (add-hook 'before-save-hook
            (lambda ()
              (when (eq major-mode 'clojure-mode)
                (clojure-align (point-min) (point-max)))))
#+end_src

Also, check that your .dir-locals.el file is properly closed with a
closing parenthesis:

#+begin_src elisp
  ((clojure-mode
    . ((clojure-align-forms-automatically . t)
       (clojure-indent-style . :always-align))))
#+end_src

If issues persist, you can manually align using =M-x clojure-align= on
the region.

* ReactDOM.render no longer supported
this clojurescript reagent code
#+begin_src clojure :file src/to/tuo/portfolio.cljs
  (ns to.tuo.portfolio
    (:require [reagent.dom :as rdom]))

  (defn hello []
    [:div
     [:h1 "hello from reagent"]
     [:p "this is a paragraph"]])

  (defn ^:export init []
    (js/console.log "hello, figwheel!")
    (rdom/render [hello] (js/document.getElementById "app")))

  (init)
#+end_src

gets the following error in the browser console
#+begin_quote
Warning: ReactDOM.render is no longer supported in React 18. Use
createRoot instead. Until you switch to the new API, your app will
behave as if it's running React 17. Learn more:
https://reactjs.org/link/switch-to-createroot <anonymous
code>:1:145535
#+end_quote

which shows this code snippet
#+begin_src js
  // Before
  import { render } from 'react-dom';
  const container = document.getElementById('app');
  render(<App tab="home" />, container);

  // After
  import { createRoot } from 'react-dom/client';
  const container = document.getElementById('app');
  const root = createRoot(container); // createRoot(container!) if you use TypeScript
  root.render(<App tab="home" />);
#+end_src

update the clojure code in the same way the javascript was updated.


Here's the updated ClojureScript code using =createRoot=:

#+begin_src clojure
  (ns to.tuo.portfolio
    (:require [reagent.dom.client :as rdom-client]))

  (defn hello []
    [:div
     [:h1 "hello from reagent"]
     [:p "this is a paragraph"]])

  (defn ^:export init []
    (js/console.log "hello, figwheel!")
    (let [root (rdom-client/create-root
                (js/document.getElementById "app"))]
      (.render root [hello])))

  (init)
#+end_src

The main changes are:
1. Require =reagent.dom.client= instead of =reagent.dom=
2. Use =create-root= to create a root instance
3. Call =.render= on the root instance


that code does not render anything in the browser and now i see this
#+begin_quote
Warning: Functions are not valid as a React child. This may happen if
you return a Component instead of <Component /> from render. Or maybe
you meant to call this function rather than return it. <anonymous
code>:1:145535
#+end_quote
* image tag in reagent
in clojurescript using reagent, make an image tag with src attribute
set to "example.jpg"

#+begin_src clojure
[:img {:src "example.jpg"}]
#+end_src

* where to put images in clojurescript reagent project?
where should i put a jpg file in a clojurescript reagent project?

In a ClojureScript Reagent project, image files like JPGs typically go
in the =public= or =resources/public= directory. They can then be
referenced in your code using relative paths starting from the public
directory.

* css make image have rounded corners and resize it
how do i make an html img tag have rounded corners and resize it to be
smaller with css?


Use CSS border-radius for rounded corners and width/height for
resizing:

#+begin_src css
img {
    border-radius: 10px;
    width: 300px;    /* or use percentage like 50% */
    height: auto;    /* maintains aspect ratio */
}
#+end_src

* can section tags be nested?
in html, can a section element be nested in another section element?


Yes, =<section>= elements can be nested within other =<section>=
elements. This is perfectly valid HTML and is commonly used to create
hierarchical content structure.

Example:
#+begin_src html
<section>
  <h2>Main Topic</h2>
  <section>
    <h3>Subtopic</h3>
    <!-- content -->
  </section>
</section>
#+end_src

* optional extension
make the file ending ".png" the default value, but also can be an
argument to the function
#+begin_src clojure
  (defn local-icon [language]
    (str "images/" language ".png"))
#+end_src

* make programming languages look nicer
with the following html
#+begin_src html
  <ul>
    <li>arm<img src="arm.svg" /></li>
    <li>bash<img src="bash.svg" /></li>
    <li>clojure<img src="clojure.svg" /></li>
  </ul>
#+end_src
and css like this
#+begin_src css
  #skills>ul {
    display: flex;
  }

  #skills>ul>li {
    display: inline-block;
  }

  #skills>ul>li>div {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
#+end_src

make the programming language appear centered over the programming
logo

Add a div wrapper around the text and image in each li, and put the
text first:

#+begin_src html
<ul>
  <li>
    <div>
      <span>arm</span>
      <img src="arm.svg" />
    </div>
  </li>
  <li>
    <div>
      <span>bash</span>
      <img src="bash.svg" />
    </div>
  </li>
  <li>
    <div>
      <span>clojure</span>
      <img src="clojure.svg" />
    </div>
  </li>
</ul>
#+end_src

The existing CSS will now center the text above each logo.

** make the list items wrap
the list of programming goes off the right edge of the window instead
of wrapping.  make it wrap.
#+begin_src html
  <ul>
    <li><span>arm<span><img src="arm.svg" /></li>
    <li><span>bash<span><img src="bash.svg" /></li>
    <li><span>clojure<span><img src="clojure.svg" /></li>
  </ul>
#+end_src
and css like this
#+begin_src css
  #skills>ul {
    display: flex;
  }

  #skills>ul>li {
    display: inline-block;
  }

  #skills>ul>li>div {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
#+end_src

Add =flex-wrap: wrap;= to the =#skills>ul= rule:

#+begin_src css
  #skills>ul {
      display: flex;
      flex-wrap: wrap;
  }
#+end_src

This will make the flex items wrap to the next line when they run out
of space.

* make them show better on dark background
some of these logos do not appear well on a dark background.  fix that.

#+begin_src html
  <ul>
    <li><div><span>arm</span><img src="arm.svg" /></div></li>
    <li><div><span>bash</span><img src="bash.svg" /></div></li>
    <li><div><span>clojure</span><img src="clojure.svg" /></div></li>
  </ul>
#+end_src

#+begin_src css
  #skills>ul { display: flex; }

  #skills>ul>li { display: inline-block; flex-wrap: wrap; }

  #skills>ul>li>div { display: flex; flex-direction: column;
    align-items: center; justify-content: center; }
#+end_src



For logos that don't show well on dark backgrounds, you can add a
light background or use CSS filters. Here's a fix:

#+begin_src css
#skills>ul>li img {
    background: white;
    border-radius: 50%;
    padding: 4px;
}
#+end_src

Also, in your HTML, you should close the =span= tags properly and use
=div= instead (since your CSS uses =div=):

#+begin_src html
<ul>
  <li><div>arm<img src="arm.svg" /></div></li>
  <li><div>bash<img src="bash.svg" /></div></li>
  <li><div>clojure<img src="clojure.svg" /></div></li>
</ul>
#+end_src
* not sure what command i just ran
i just ran some command in spacemacs with a keyboard shortcut.  now i
am unable to modify a src block in an org mode file.  when i try, i
see the message "user-error: Cannot modify an area being edited in a
dedicated buffer".  what did i do?  how do i find out what the command
was?  how do i make the src block editable again?

It sounds like you accidentally opened the source block in a dedicated
buffer (probably with =C-c '= or similar) but didn't close it
properly.

To find the command history:
- =C-h l= (view-lossage) shows recent commands

To fix this:
1. Look for any other buffers with the source code open
2. Close them with =C-c '= or =C-x k=
3. Try editing the source block again

If you can't find the buffer, you might need to restart Emacs as a
last resort.
* turn "-" into " "
turn all "-" into " " in a string in clojure


In Clojure, you can use =clojure.string/replace=:

#+begin_src clojure
(clojure.string/replace "hello-world-example" #"-" " ")
;; => "hello world example"
#+end_src

Or with require:
#+begin_src clojure
(require '[clojure.string :as str])
(str/replace "hello-world-example" #"-" " ")
#+end_src

* soften border
how do i make the border blend with the background 50% with css?
#+begin_src css
  @property --foreground-color {
    syntax: '<color>';
    initial-value: chartreuse;
    inherits: true;
  }
  @property --background-color {
    syntax: '<color>';
    initial-value: #111;
    inherits: true;
  }

  ,* {
    color: var(--foreground-color);
    background-color: var(--background-color);
    margin: 0;
    padding: 0;
  }
  #skills>ul>li {
    display: inline-block;
    margin: 1em;
    width: 140px;
    border: 1px solid;
    border-radius: 10px;
    padding: 1em;
  }
#+end_src

using the var "--foreground-color"?


Add =border-color= with =opacity= using =rgba()=. Here's how:

#+begin_src css
#skills>ul>li {
    /* ... other properties ... */
    border: 1px solid rgba(var(--foreground-color), 0.5);
}
#+end_src

Or using the modern way with =color-mix=:

#+begin_src css
    #skills>ul>li {
        /* ... other properties ... */
        border: 1px solid
                color-mix(in srgb,
                          var(--foreground-color) 50%,
                          transparent);
    }
#+end_src

* one css var based on other css var?
#+begin_src css
  @property --light-color {
    syntax: '<color>';
    initial-value: #eee;
    inherits: true;
  }
  @property --foreground-color {
    syntax: '<color>';
    initial-value: #eee;
    inherits: true;
  }
#+end_src
make it so =--foreground-color='s initial value is =--light-color=.

can this be done?


Yes, it can be done. You can reference custom properties as initial
values. Here's how:

#+begin_src css
  @property --foreground-color {
    syntax: '<color>';
    initial-value: var(--light-color);
    inherits: true;
  }
#+end_src

This will make =--foreground-color= initially take the value of
=--light-color=.

that did not work.  instead, color is set to white, and the inspector
says "--foreground-color" is not set.


You're right - I apologize for the incorrect information. According to
the CSS specification, =@property= rules cannot reference other custom
properties in their =initial-value=. The =initial-value= must be a
direct, valid value of the specified syntax type.

This is a limitation of the =@property= rule. You'll need to either:
1. Set both properties to the same literal value, or
2. Handle the relationship between these properties in your regular
   CSS rules instead

i want to have a way of explicitly specifying "light" color for the
background of icons that need a light background.  i also want a
variable for "foreground-color" that can change to match the system
theme.  i want the foreground-color to initially start with the light
color, and then change based on the system theme.


Here's a solution using regular CSS custom properties (without
@property):

#+begin_src css
  :root {
    --light-color: #eee;
    --foreground-color: var(--light-color);
  }

  @media (prefers-color-scheme: dark) {
    :root {
      --foreground-color: #333;
    }
  }
#+end_src

This sets up --light-color as a constant and --foreground-color
initially matches it, but will change to dark in dark mode. No need
for @property rules in this case.

* how to set color as early as possible, and have it overridden
i want to set the color for my page as soon as possible, so i have
inline css to set the color.
#+begin_src html
  <!doctype html>
  <html>
    <head>
      <meta charset="UTF-8" />
      <style>
        body {
          color: white;
          background-color: black;
        }
      </style>
      <link rel="stylesheet" type="text/css"  href="css/style.css">
      <title>figwheel main example</title>
    </head>
    <body>
      <div id="app"></div>
      <script src="/cljs-out/dev-main.js"></script>
    </body>
  </html>
#+end_src

i also want to later change the color when i load css, so i have this
rule
#+begin_src css
  @media (prefers-color-scheme: light) {
    :root {
      --foreground-color: var(--night-color);
      --backround-color: var(--light-color);
    }
  }
  ,* {
    color: var(--foreground-color);
    background-color: var(--background-color);
  }
#+end_src

the rule at the end for setting =color: var(--foreground-color);= and
=background-color: var(--background-color);= is being overridden by
the inline rule.  how do i both set a color as early as possible, and
later change it based on things like media query?

To achieve both immediate color setting and later flexibility, you can
use CSS custom properties (variables) in your inline style and
redefine them later. Here's how:

#+begin_src html
  <style>
    :root {
      --foreground-color: white;
      --background-color: black;
    }
    body {
      color: var(--foreground-color);
      background-color: var(--background-color);
    }
  </style>
#+end_src

Then in your CSS file, you can redefine the variables:

#+begin_src css
  @media (prefers-color-scheme: light) {
    :root {
      --foreground-color: var(--night-color);
      --background-color: var(--light-color);
    }
  }
#+end_src

This way you get immediate color application while maintaining the
ability to change them dynamically later.

* css color transition
when i change my system color preference, the page colors change,
but they change immediately instead of transitioning slowly.  why?
#+begin_src html
  <!doctype html>
  <html>

  <head>
      <meta charset="UTF-8" />
      <style>
          @property --foreground-color {
              syntax: '<color>';
              inherits: true;
          }

          @property --background-color {
              syntax: '<color>';
              inherits: true;
          }

          :root {
              --light-color: #eee;
              --night-color: #111;
              --foreground-color: var(--light-color);
              --background-color: var(--night-color);
              transition: --foreground-color 5s ease,
                  --background-color 5s ease;
          }

          body {
              color: var(--foreground-color);
              background-color: var(--background-color);
          }
      </style>
      <link rel="stylesheet" type="text/css" href="css/style.css">
      <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/devicon.min.css" />
      <title>daniel watson's portfolio</title>
  </head>

  <body>
      <div id="app"></div>
      <script src="/cljs-out/dev-main.js"></script>
  </body>

  </html>
#+end_src

#+begin_src css
  @media (prefers-color-scheme: light) {
    :root {
      --foreground-color: var(--night-color);
      --background-color: var(--light-color);
    }
  }

  :root {
  }

  ,* {
    color: var(--foreground-color);
    background-color: var(--background-color);
    margin: 0;
    padding: 0;
  }

  header {
    display: flex;
    justify-content: space-between;
    padding: 1em;
  }

  h1 {
    font-size: xx-large;
  }

  #skills>ul {
    display: flex;
    flex-wrap: wrap;
  }

  #skills>ul>li {
    display: inline-block;
    margin: 1em;
    width: 140px;
    border: 1px
            solid
            color-mix(in srgb,
                      var(--foreground-color) 20%,
                      transparent);
    border-radius: 10px;
    padding: 1em;
  }

  #skills>ul>li>div>span {
    padding: 0.5em;
  }

  #skills>ul>li>div>img {
    border-radius: 10%;
    padding: 4px;
  }

  #skills>ul>li>div>img.night {
    background-color: var(--night-color);
  }

  #skills>ul>li>div>img.light {
    background-color: var(--light-color);
  }

  #skills>ul>li>div {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
#+end_src

i want to make it so changes to the vars =--foreground-color= and
=--background-color= are done with a smooth transition.

The issue is that the CSS custom property transitions aren't working
because you need to add =initial-value= to your =@property=
declarations. Here's the fix:

#+begin_src css
@property --foreground-color {
    syntax: '<color>';
    inherits: true;
    initial-value: #eee; /* Add this */
}

@property --background-color {
    syntax: '<color>';
    inherits: true;
    initial-value: #111; /* Add this */
}
#+end_src

Without initial values, the browser doesn't know how to interpolate
between the colors during the transition. Adding these values enables
the smooth transition effect you're looking for.

* set transition in property
is there a way to set the transition rule inside the property ruleset
for =--foreground-color= equivalent to this?
#+begin_src css
  @property --foreground-color {
      syntax: '<color>';
      inherits: true;
      initial-value: #eee;
      /* put transition rules here */
  }

  @property --background-color {
      syntax: '<color>';
      inherits: true;
      initial-value: #111;
      /* put transition rules here */
  }

  :root {
      --light-color: #eee;
      --night-color: #111;
      /* move this from :root into @property rules above */
      transition: --foreground-color 1s ease,
          --background-color 1s ease;
  }
#+end_src



No, transitions cannot be defined within =@property=
rules. Transitions must be defined in regular CSS rulesets (like
=:root= or other selectors) using the =transition= property as you've
shown. The =@property= syntax only allows for defining the property's
characteristics like syntax, inheritance, and initial value.

* get accent color through css
how do i get the accent color of the system through css?


In CSS, you can use the =accent-color= system color keyword like this:

#+begin_src css
  element {
    color: AccentColor;
    /* or */
    background-color: AccentColor;
  }
#+end_src

This works in modern browsers but support may vary. For broader
compatibility, you might need to use platform-specific solutions or
JavaScript APIs.
